
<!-- 该代码和3.html完全不一样，先保存 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>validators</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
</head>
<body style="margin-left: 100px;">
    <svg id="mainsvg" width="4200" height="3600"  class="svgs" :style="background-color: #ffffff;"></svg>
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <style>
        .axis text{
            font-family: sans-serif;
            font-size: 11px;
        }
    </style>
    <script>
        //设置svg
    let svg = d3.select('svg');
    const width = (+svg.attr('width')-200)/2;
    const height = (+svg.attr('height')-1200)/2;
    const margin = { top: 100, right: 90, bottom: 160, left:190 };
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;
    const g = svg.append('g').attr('id', 'maingroup')
      .attr('transform', `translate(${margin.left},${margin.top})`);

      
var d=eval('{{d|safe}}');
var proposer=eval('{{proposer}}');

console.log(d);


for(i=0;i<proposer.length;i++){
    proposer[i].sort(function(x,y){
        return x-y;
    });
}


console.log(proposer);
var data=[];
  //  d3.json('epoch100.json').then(d=>{    //默认validator是升序的
          //数据处理
 const SUM=d[0].validator.length;

    data=d;
    // console.log(data.length);
    var graph=[];
    for(let i=0;i<data.length;i++){
      graph.push([]);
      for(let j=0;j<3;j++){
         graph[i].push([]);
         for(var k=0;k<3;k++)
         graph[i][j].push([]);
    }
}
for(let i=0,index=data.length-1;i<data.length;i++,index--){   //index为graph位置
      for(let j=0;j<data[i].validator.length;j++){
        var k=1;
          if(i>0)
            k+=data[i-1].validator[j].vote;
        graph[index][data[i].validator[j].vote+1][k].push(data[i].validator[j].validator_index);
      }
}
    // console.log(graph);
    //  console.log(data);
    var data_rect_tmp=[];
    var data_rect=[];
    for(let i=0;i<graph.length;i++){
        data_rect_tmp.push([]);
         for(let j=0;j<3;j++){
             var sum=0;
             for(let k=0;k<3;k++){
                 sum+=graph[i][j][k].length;
             }
             data_rect_tmp[i].push(sum);
             data_rect.push({i:i,j:j,size:sum});
         }
    }
    
//  console.log(graph)
 //设置矩阵的行列
var r=2,c=graph.length;
const yValue=['approve', 'abstain','decline'];
const xValue=[];
for(let i=c-1;i>=0;i--){
    xValue.push('epoch:'+data[i].epoch);
}
//设置坐标轴
const xscale = d3.scaleBand()
        .domain(xValue)
        .range([0, innerWidth]);
const xscale2 = d3.scaleLinear()
        .domain([0,data_rect_tmp.length])
        .range([0, innerWidth]);
const yscale = d3.scalePoint() 
        .domain(yValue)
        .range([innerHeight,0])
const yscale2 = d3.scaleLinear() 
        .domain([0,2])
        .range([0,innerHeight])
const yaxis = d3.axisLeft(yscale)
        .ticks(r)
        .tickSize(10)
        .tickPadding(10)
       
const xaxis = d3.axisTop(xscale)
        .ticks(c)
        .tickSize(-10)
        .tickPadding(-50);
g.append('g').call(yaxis)
        .attr('id' ,'yaxis') 
        .style("font-size","24px");
 
g.append('g').call(xaxis)
        .attr('id', 'xaxis')
        .attr('transform', `translate(0, ${innerHeight})`)
        .style("font-size","20px");
//添加矩阵
const  rect_width=innerWidth/(2*c);
const  sub_width=innerWidth/c-rect_width;
const rect_height_I=innerHeight/SUM;
g.selectAll('.datarect').data(data_rect).enter().append('rect')
.attr('class','datarect')
.attr('width',rect_width)
.attr('height', d=>d.size*rect_height_I)
.attr('y',d=>(yscale2(d.j)-d.size*rect_height_I/2))
.attr('x',d=>xscale2(d.i))
.attr('fill','black')
.attr('opacity',0.3);
//console.log(data_rect_tmp);
function make_path(i,j,k,size_r_1,size_line_1,size_r_2){
     var path=d3.path();
     var x1=(i+1)*rect_width+i*sub_width;
     var x2=x1+sub_width;

     var yl1=yscale2(j)-size_r_1*rect_height_I/2;
     for(var tm=0;tm<k;tm++)
        yl1+=graph[i][j][tm].length*rect_height_I;
     var yl2=yl1+size_line_1*rect_height_I;

     var yr1=yscale2(k)-size_r_2*rect_height_I/2;
     for(var tm=0;tm<j;tm++)
        yr1+=graph[i][tm][k].length*rect_height_I;
      var yr2=yr1+size_line_1*rect_height_I;
      
      var dx=(x2-x1)/10;
      var dy=(yr1-yl1)/3;
      let cpx1 = x1 - dx;
      let cpy1 = yl1 + dy;
      let cpx2 = x2 + dx;
      let cpy2 = yr1 - dy;
      var dhy=yl2-yl1;
      path.moveTo(x1,yl1);
      path.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x2,yr1);
      path.lineTo(x2,yr2);
      path.bezierCurveTo(cpx2,cpy2+dhy,cpx1,cpy1+dhy,x1,yl2);
      path.lineTo(x1,yl1);
      g.append('path')
            .attr('d', path.toString())
            .style('fill','blue')
            .style('stroke','red')
            .style('stroke-width','2')
         //   .style('opicity','0.');
      
}
//绘制曲线
for(var i=0;i<graph.length-1;i++){
    for(var j=0;j<3;j++){
        for(var k=0;k<3;k++){
             make_path(i,j,k,data_rect_tmp[i][j],graph[i][j][k].length,data_rect_tmp[i+1][k]);     //j决定第i块位置，k决定第i+1块，同时k决定i的矩形位置，j决定i+1的矩形位置
        }
    }
}
//})

    </script>
</body>
</html>