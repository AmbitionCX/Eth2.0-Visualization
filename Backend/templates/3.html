<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>validators</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
</head>
<body style="margin-left: 100px;">
    <svg id="mainsvg" width="4200" height="3600"  class="svgs" :style="background-color: #ffffff;"></svg>
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <style>
        .axis text{
            font-family: sans-serif;
            font-size: 11px;
        }
    </style>
    <script>
        //设置svg
    let svg = d3.select('svg');
    const width = (+svg.attr('width')-200)/2;
    const height = (+svg.attr('height')-1200)/2;
    const margin = { top: 100, right: 90, bottom: 160, left:190 };
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;
    const g = svg.append('g').attr('id', 'maingroup')
      .attr('transform', `translate(${margin.left},${margin.top})`);

      
var d=eval('{{d|safe}}');
var proposer=eval('{{proposer}}');



//  //升序排列
// for(i=0;i<proposer.length;i++){
//     proposer[i].sort(function(x,y){
//         return x-y;
//     });
// }
// for(i=0;i<d.length;i++){
//     d[i].validator.sort(function(x,y){
//         return x.validator_index-y.validator_index;
//     })
// }   
//默认flask里面已经处理好了

for(j=d[d.length-1].validator.length-1;j>0&&d[d.length-1].validator[j].vote==-2;j--)

for(i=0;i<d.length;i++){
    d[i].validator.splice(j,1);
}

var data=d.reverse();
proposer=proposer.reverse();


  //  d3.json('epoch100.json').then(d=>{    //默认validator是升序的
          //数据处理
// console.log(data);
 const SUM=data[0].validator.length;


//  console.log(data);

 var graph=[];
 var v_line=[];
 for(var i=0;i<SUM;i++)
   v_line.push({index:data[0].validator[i].validator_index,node:[]});
 for(var i=0;i<data.length;i++){
    graph.push([]);
    for( var j=0;j<2;j++){
        graph[i].push(0);
    }
 }

 //graph保留数量信息

for(var j=0;j<SUM;j++){
  for(var i=0,k=0;i<data.length;i++){
    var Y=data[i].validator[j].vote+1;
    if(Y==-1)
       console.log(i,j);
    if(Y<2){
    if(Y<0)
        Y=0;
    var X= ++graph[i][Y];
    v_line[j].node.push( {dy:X,y:Y,ispro:0});
    }
    else{
     v_line[j].node.push( {dy:0,y:2,ispro:0})
    }
   }
}
console.log(proposer);
console.log(graph);
console.log(v_line);

    var data_rect=[];
   for(var i=0;i<graph.length;i++){
       for(var j=0;j<graph[i].length;j++){
        data_rect.push({i:i,j:j,size:graph[i][j]})
       }
   }

 //设置矩阵的行列
var r=2,c=data.length;
const yValue=['decline','abstain'];
const xValue=[];
for(let i=0;i<c;i++){
    xValue.push('epoch:'+data[i].epoch);
}
//设置坐标轴
const xscale = d3.scaleBand()
        .domain(xValue)
        .range([0, innerWidth]);

 const xscale2 = d3.scaleLinear()
        .domain([0,c])
        .range([0, innerWidth]);
const yscale = d3.scalePoint() 
        .domain(yValue)
        .range([innerHeight,0])
        
const yscale2 = d3.scaleLinear() 
        .domain([0,1])
        .range([0,innerHeight])
const yaxis = d3.axisLeft(yscale)
        .ticks(r)
        .tickSize(10)
        .tickPadding(10)
const xaxis = d3.axisTop(xscale)
        .ticks(c)
        .tickSize(-10)
        .tickPadding(-50);
g.append('g').call(yaxis)
        .attr('id' ,'yaxis') 
        .style("font-size","24px");
 
g.append('g').call(xaxis)
        .attr('id', 'xaxis')
        .attr('transform', `translate(0, ${innerHeight})`)
        .style("font-size","20px");
//添加矩阵

const  rect_width=innerWidth/(5*c);
const  sub_width=innerWidth/c-rect_width;
const rect_height_I=innerHeight/SUM;
// g.selectAll('.datarect').data(data_rect).enter().append('rect')
// .attr('class','datarect')
// .attr('width',rect_width)
// .attr('height', d=>d.size*rect_height_I)
// .attr('y',function(d){
//     if(!d.j)
//     return (yscale2(d.j));
//     else
//     return yscale2(d.j)-d.size*rect_height_I;
// })
// .attr('x',d=>xscale2(d.i))
// .attr('fill',function(d){
//     if(!d.j)
//     return 'grey';
//     else 
//     return 'red';
// })
// .attr('opacity',0.8);


var x1=[];
var x2=[];
for(j=0;j<data.length-1;j++){
       x1.push((j+1)*rect_width+j*sub_width+sub_width/2);
       x2.push((j+1)*rect_width+(j+1)*sub_width+sub_width/2);
  }
// console.log(x1,x2);
function make_line(i){
      var Y=[];
      var y1=[];
      var y2=[];
      for(j=0;j<data.length;j++){
        var h;
        rect_height_I*v_line[i].node[j].dy+yscale2(v_line[i].node[j].y);
        if(v_line[i].node[j].y==2)
            h=0;
        else if(v_line[i].node[j].y==0)
            h=rect_height_I*v_line[i].node[j].dy+yscale2(v_line[i].node[j].y)+(SUM-graph[j][0]-graph[j][1])*rect_height_I;
        else 
           h=rect_height_I*v_line[i].node[j].dy+yscale2(v_line[i].node[j].y)-graph[j][1]*rect_height_I;
        Y.push(h);
        if(j<data.length-1)
        y1.push(h);
        if(j)
        y2.push(h);
    }
    var path=d3.path();
    for(j=0;j<y1.length;j++){
       if((v_line[i].node[j+1].y==1||v_line[i].node[j+1].y==0)&&(v_line[i].node[j].y==0||v_line[i].node[j].y==1)){
        var dx=(x2[j]-x1[j])/20;
        var dy=(y2[j]-y1[j])/3;
        let cpx1 = x1[j] + dx;
        let cpy1 = y1[j] + dy;
        let cpx2 = x2[j] - dx;
        let cpy2 = y2[j] - dy;
        path.moveTo(x1[j],y1[j]);
        //path.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x2[j],y2[j]);  //曲线
        path.lineTo(x2[j],y2[j]);                                //直线
       }

    }
    g.append('path')
            .attr('class','v_line')
            .attr('d', path.toString())
            .style('stroke','blue')
            .style('stroke-width','0.5')
            .style('fill','none')
            
           
}
function make_rect(i){
    for(j=0;j<v_line[i].node.length;j++){
    if(v_line[i].node[j].y!=2){
var y=v_line[i].node[j].y;
var dy=v_line[i].node[j].dy;
 g.append('rect')
.attr('class','v_rect')
.attr('width',rect_width)
.attr('height', rect_height_I*0.9)
.attr('y',function(){
    var ans;
    if(!y)
    ans= (yscale2(y))+(dy-1)*rect_height_I+(SUM-graph[j][0]-graph[j][1])*rect_height_I;
    else
    ans=yscale2(y)-graph[j][1]*rect_height_I+(dy-1)*rect_height_I;
    return ans;
})
.attr('x',xscale2(j)+sub_width/2)
.attr('fill',function(){
    if(!y)
     return 'grey';
    else 
     return 'red';
})
.attr('opacity',0.8);

    }

  }
}
for(var i=0;i<v_line.length;i++){
       make_line(i);
       make_rect(i);
}

    </script>
</body>
</html>